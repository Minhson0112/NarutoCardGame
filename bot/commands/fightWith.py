import discord
from discord.ext import commands
from discord import app_commands
import random
import asyncio

from bot.config.database import getDbSession
from bot.repository.playerRepository import PlayerRepository
from bot.repository.playerCardRepository import PlayerCardRepository
from bot.repository.playerWeaponRepository import PlayerWeaponRepository
from bot.repository.playerActiveSetupRepository import PlayerActiveSetupRepository
from bot.repository.dailyTaskRepository import DailyTaskRepository
from bot.config.imageMap import CARD_IMAGE_LOCAL_PATH_MAP, BG_FIGHT, NON_CARD_PATH
from bot.entity.player import Player
from bot.services.battle import Battle
from bot.services.fightRender import renderImageFight
from bot.services.help import get_battle_card_params, render_team_status
from bot.services.createCard import create_card

class FightWith(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.active_fights: set[int] = set()

    @app_commands.command(name="fightwith", description="Pk vui v·ªõi ng∆∞·ªùi ch∆°i ƒë√£ tag (kh√¥ng c·∫≠p nh·∫≠t rank)")
    @app_commands.describe(
        target="Tag c·ªßa ng∆∞·ªùi ch∆°i b·∫°n mu·ªën pk"
    )
    async def fightwith(self, interaction: discord.Interaction, target: discord.Member):
        attacker_id = interaction.user.id
        defender_id = target.id
        if attacker_id in self.active_fights:
            await interaction.response.send_message(
            "‚ö†Ô∏è B·∫°n ƒëang trong tr·∫≠n ƒë·∫•u, vui l√≤ng ch·ªù cho tr·∫≠n tr∆∞·ªõc k·∫øt th√∫c r·ªìi m·ªõi /fight ti·∫øp!",
            ephemeral=True
            )
            return
            
        await interaction.response.defer(thinking=True)
        try:
            with getDbSession() as session:
                # L·∫•y c√°c repository c·∫ßn thi·∫øt
                playerRepo = PlayerRepository(session)
                cardRepo = PlayerCardRepository(session)
                weaponRepo = PlayerWeaponRepository(session)
                activeSetupRepo = PlayerActiveSetupRepository(session)
                dailyTaskRepo = DailyTaskRepository(session)
                
                # L·∫•y th√¥ng tin ng∆∞·ªùi t·∫•n c√¥ng
                attacker = playerRepo.getById(attacker_id)
                if not attacker:
                    await interaction.followup.send("‚ö†Ô∏è B·∫°n ch∆∞a ƒëƒÉng k√Ω t√†i kho·∫£n. H√£y d√πng /register tr∆∞·ªõc nh√©!")
                    return

                if defender_id == attacker_id:
                    await interaction.followup.send("‚ö†Ô∏è B·∫°n kh√¥ng th·ªÉ pk v·ªõi ch√≠nh m√¨nh.")
                    return
                # L·∫•y active setup c·ªßa ng∆∞·ªùi t·∫•n c√¥ng
                attackerSetup = activeSetupRepo.getByPlayerId(attacker_id)
                # Ki·ªÉm 3 slot th·∫ª
                slots = [
                    attackerSetup.card_slot1,
                    attackerSetup.card_slot2,
                    attackerSetup.card_slot3,
                ]
                if any(slot is None for slot in slots):
                    await interaction.followup.send(
                        "‚ö†Ô∏è B·∫°n ph·∫£i l·∫Øp ƒë·ªß 3 th·∫ª (Tanker, Middle, Back) m·ªõi c√≥ th·ªÉ tham gia ƒë·∫•u!"
                    )
                    return

                # N·∫øu ƒë·∫ßy ƒë·ªß, l·∫•y ra c√°c ƒë·ªëi t∆∞·ª£ng PlayerCard
                attacker_cards = [
                    cardRepo.getById(slot_id)
                    for slot_id in slots
                ]

                # l√¢ÃÅy vuÃÉ khiÃÅ
                attacker_weapon_slots = [
                    attackerSetup.weapon_slot1,
                    attackerSetup.weapon_slot2,
                    attackerSetup.weapon_slot3,
                ]
                attacker_weapons = [
                    weaponRepo.getById(wsid) if wsid is not None else None
                    for wsid in attacker_weapon_slots
                ]

                battle_attacker_team = []
                for pc, pw in zip(attacker_cards, attacker_weapons):
                    # L·∫•y tuple params ƒë√£ buff level + bonus v≈© kh√≠
                    params = get_battle_card_params(pc, pw)
                    # Create ƒë√∫ng subclass d·ª±a tr√™n element v√† tier
                    battle_card = create_card(*params)
                    battle_attacker_team.append(battle_card)

                opponents = playerRepo.getById(defender_id)
                if not opponents:
                    await interaction.followup.send("‚ö†Ô∏è Ng∆∞·ªùi ch∆°i ƒë∆∞·ª£c tag ch∆∞a t·∫°o t√†i kho·∫£n.")
                    return
                
                oppSetup = activeSetupRepo.getByPlayerId(opponents.player_id)
                if not oppSetup or any(slot is None for slot in (oppSetup.card_slot1, oppSetup.card_slot2, oppSetup.card_slot3)):
                    await interaction.followup.send("‚ö†Ô∏è Ng∆∞·ªùi ch∆°i ƒë∆∞·ª£c tag ch∆∞a s·∫µn s√†ng pk (thi·∫øu th·∫ª).")
                    return
                
                defenderSetup = oppSetup
                # L·∫•y ra list 3 PlayerCard c·ªßa defender
                defender_slots = [
                    defenderSetup.card_slot1,
                    defenderSetup.card_slot2,
                    defenderSetup.card_slot3,
                ]
                defender_cards = [cardRepo.getById(cid) for cid in defender_slots]

                # l√¢ÃÅy vuÃÉ khiÃÅ 
                defender_weapon_slots = [
                    defenderSetup.weapon_slot1,
                    defenderSetup.weapon_slot2,
                    defenderSetup.weapon_slot3,
                ]
                defender_weapons = [
                    weaponRepo.getById(wsid) if wsid is not None else None
                    for wsid in defender_weapon_slots
                ]

                battle_defender_team = []
                for pc, pw in zip(defender_cards, defender_weapons):
                    params = get_battle_card_params(pc, pw)
                    battle_defender_team.append(create_card(*params))

                paths = []

                for pc in attacker_cards + defender_cards:
                    key = pc.template.image_url
                    # n·∫øu kh√¥ng t√¨m th·∫•y key trong map th√¨ fallback sang NON_CARD_PATH n·∫øu b·∫°n c√≥
                    img_path = CARD_IMAGE_LOCAL_PATH_MAP.get(key, NON_CARD_PATH)
                    paths.append(img_path)

                # paths b√¢y gi·ªù l√† [a1, a2, a3, d1, d2, d3]

                # 2) G·ªçi renderImageFight
                buffer = renderImageFight(
                    paths[0], paths[1], paths[2],
                    paths[3], paths[4], paths[5],
                    BG_FIGHT
                )
                filename = f"battle_{attacker_id}.png"
                battle_file = discord.File(buffer, filename=filename)  

                for c in battle_attacker_team:
                    c.team      = battle_attacker_team
                    c.enemyTeam = battle_defender_team

                # --- G√°n team/enemyTeam cho defender ---
                for c in battle_defender_team:
                    c.team      = battle_defender_team
                    c.enemyTeam = battle_attacker_team

                self.active_fights.add(attacker_id)

                # 1) G·ª≠i embed log ban ƒë·∫ßu k√®m ·∫£nh
                initial_desc = []
                initial_desc += render_team_status(battle_attacker_team, "**Team T·∫•n C√¥ng**")
                initial_desc += render_team_status(battle_defender_team, "**Team Ph√≤ng Th·ªß**")
                initial_desc.append("\nƒêang kh·ªüi ƒë·∫ßu tr·∫≠n ƒë·∫•u‚Ä¶")

                log_embed = discord.Embed(
                    title=f"üî• Battle Log {attacker.username} VS {opponents.username}",
                    description="\n".join(initial_desc),
                    color=discord.Color.blurple()
                )
                log_embed.set_image(url=f"attachment://{filename}")
                log_msg = await interaction.followup.send(
                    embed=log_embed,
                    file=battle_file,
                    wait=True
                )

                #..........................battle.................................
                battle = Battle(battle_attacker_team, battle_defender_team, maxturn=120)
                while (
                    battle.is_team_alive(battle.attacker_team) and
                    battle.is_team_alive(battle.defender_team) and
                    battle.turn <= battle.maxturn
                ):
                    for atk_team, def_team in (
                        (battle.first_team, battle.second_team),
                        (battle.second_team, battle.first_team)
                    ):
                        for c in atk_team:
                            if not c.is_alive():
                                continue
                            logs = battle.battle_turn_one_card(c)
                            static_lines = []
                            static_lines += render_team_status(battle_attacker_team, "**Team T·∫•n C√¥ng**")
                            static_lines += render_team_status(battle_defender_team, "**Team Ph√≤ng Th·ªß**")
                            desc = "\n".join(static_lines)
                            desc += f"\n--- L∆∞∆°Ã£t {battle.turn}: {c.name} ---\n"
                            desc += "\n".join(logs)

                            edit_embed = discord.Embed(
                                title=f"üî• Battle Log {attacker.username} VS {opponents.username}",
                                description=desc,
                                color=discord.Color.blurple()
                            )
                            edit_embed.set_image(url=f"attachment://{filename}")
                            await log_msg.edit(embed=edit_embed)
                            await asyncio.sleep(2)
                            battle.turn += 1
                            if not battle.is_team_alive(def_team):
                                break
                        if not battle.is_team_alive(def_team):
                            break

                # x√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng
                if battle.turn >= battle.maxturn:
                    result = "üè≥Ô∏è Ho√†"
                    outcome_text = "‚öîÔ∏è Hai ƒë·ªôi qu√° c√¢n s·ª©c (120 v√≤ng) n√™n ho√†!."
                elif battle.is_team_alive(battle.attacker_team):
                    result = "Chi√™ÃÅn ThƒÉÃÅng"
                else:
                    result = "Th√¢ÃÅt BaÃ£i"

                dailyTaskRepo.updateFightwith(attacker_id)
                session.commit()
                outcome_text = f" **ƒêi√™Ãâm Rank:** viÃÄ kh√¥ng phaÃâi ƒëaÃÅnh rank n√™n kh√¥ng ai nh√¢Ã£n ƒë∆∞∆°Ã£c th∆∞∆°Ãâng hay ƒëi√™m rank"

                # 3) G·ª≠i embed k·∫øt qu·∫£ cu·ªëi c√πng
                result_embed = discord.Embed(
                    title=f"üèÅ K·∫øt quaÃâ tr√¢Ã£n chi√™ÃÅn cuÃâa {attacker.username} VS {opponents.username}",
                    description=(
                        f"üéñÔ∏è **K·∫øt qu·∫£:** {result}\n"
                        f"üí∞**Th∆∞·ªüng:** 0 Ryo\n"
                        f"üèÜ**Chu·ªói th·∫Øng:** Kh√¥ng biÃ£ thay ƒë√¥Ãâi\n"
                        f"{outcome_text}"
                    ),
                    color=discord.Color.green() if result == "Chi√™ÃÅn ThƒÉÃÅng" else discord.Color.red()
                )
                result_embed.set_footer(text=f"ƒêi·ªÉm Rank: {attacker.rank_points}")
                await interaction.followup.send(embed=result_embed)

        except Exception as e:
            print("‚ùå L·ªói khi x·ª≠ l√Ω fightwith:", e)
            await interaction.followup.send("‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.")
        finally:
            self.active_fights.remove(attacker_id)
async def setup(bot):
    await bot.add_cog(FightWith(bot))
