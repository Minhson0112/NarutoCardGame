import discord
from discord.ext import commands
from discord import app_commands
from discord.app_commands import checks, CommandOnCooldown
import random
import asyncio
import traceback

from bot.config.database import getDbSession
from bot.repository.playerRepository import PlayerRepository
from bot.repository.playerCardRepository import PlayerCardRepository
from bot.repository.playerWeaponRepository import PlayerWeaponRepository
from bot.repository.playerActiveSetupRepository import PlayerActiveSetupRepository
from bot.repository.cardTemplateRepository import CardTemplateRepository
from bot.repository.dailyTaskRepository import DailyTaskRepository
from bot.repository.playerCardRepository import PlayerCardRepository
from bot.repository.weaponTemplateRepository import WeaponTemplateRepository
from bot.repository.playerWeaponRepository import PlayerWeaponRepository
from bot.config.imageMap import CARD_IMAGE_LOCAL_PATH_MAP,TAILED_IMAGE_LOCAL_PATH_MAP , BG_TAILED, NON_CARD_PATH
from bot.config.gachaConfig import GACHA_DROP_RATE
from bot.config.weaponGachaConfig import WEAPON_GACHA_DROP_RATE
from bot.services.tailedRender import renderImageFight
from bot.services.battle import Battle
from bot.services.help import get_battle_card_params, render_team_status
from bot.services.createCard import create_card

class TailedBoss(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    @app_commands.command(name= "tailedboss", description= "sƒÉn vƒ© th√∫ nh·∫≠n ryo, th·∫ª v√† v≈© kh√≠")
    @checks.cooldown(1, 3600, key=lambda interaction: interaction.user.id)
    async def tailedboss(self, interaction: discord.Interaction):
        attacker_id = interaction.user.id
        await interaction.response.defer(thinking=True)

        type1OfTailed = ["1vi", "2vi", "3vi", "4vi", "5vi", "6vi", "7vi"]

        try:
            with getDbSession() as session:
                # L·∫•y c√°c repository c·∫ßn thi·∫øt
                playerRepo = PlayerRepository(session)
                cardRepo = PlayerCardRepository(session)
                weaponRepo = PlayerWeaponRepository(session)
                activeSetupRepo = PlayerActiveSetupRepository(session)
                dailyTaskRepo = DailyTaskRepository(session)
                cardtemplaterepo = CardTemplateRepository(session)
                playerCardRepo = PlayerCardRepository(session)
                weaponTemplateRepo = WeaponTemplateRepository(session)
                playerWeaponRepo = PlayerWeaponRepository(session)

                # L·∫•y th√¥ng tin ng∆∞·ªùi t·∫•n c√¥ng
                attacker = playerRepo.getById(attacker_id)
                if not attacker:
                    await interaction.followup.send("‚ö†Ô∏è B·∫°n ch∆∞a ƒëƒÉng k√Ω t√†i kho·∫£n. H√£y d√πng /register tr∆∞·ªõc nh√©!")
                    return

                # L·∫•y active setup c·ªßa ng∆∞·ªùi t·∫•n c√¥ng
                attackerSetup = activeSetupRepo.getByPlayerId(attacker_id)
                # Ki·ªÉm 3 slot th·∫ª
                slots = [
                    attackerSetup.card_slot1,
                    attackerSetup.card_slot2,
                    attackerSetup.card_slot3,
                ]
                if any(slot is None for slot in slots):
                    await interaction.followup.send(
                        "‚ö†Ô∏è B·∫°n ph·∫£i l·∫Øp ƒë·ªß 3 th·∫ª (Tanker, Middle, Back) m·ªõi c√≥ th·ªÉ tham gia ƒë·∫•u!"
                    )
                    return

                # N·∫øu ƒë·∫ßy ƒë·ªß, l·∫•y ra c√°c ƒë·ªëi t∆∞·ª£ng PlayerCard
                attacker_cards = [
                    cardRepo.getById(slot_id)
                    for slot_id in slots
                ]

                # l√¢ÃÅy vuÃÉ khiÃÅ
                attacker_weapon_slots = [
                    attackerSetup.weapon_slot1,
                    attackerSetup.weapon_slot2,
                    attackerSetup.weapon_slot3,
                ]
                attacker_weapons = [
                    weaponRepo.getById(wsid) if wsid is not None else None
                    for wsid in attacker_weapon_slots
                ]

                battle_attacker_team = []
                for pc, pw in zip(attacker_cards, attacker_weapons):
                    # L·∫•y tuple params ƒë√£ buff level + bonus v≈© kh√≠
                    params = get_battle_card_params(pc, pw)
                    # Create ƒë√∫ng subclass d·ª±a tr√™n element v√† tier
                    battle_card = create_card(*params)
                    battle_attacker_team.append(battle_card)

                battle_defender_team = []
                defenderCardImgPaths = []
                list_cards = cardtemplaterepo.getRandomTailedCard()
                for card in list_cards:
                    img_path = TAILED_IMAGE_LOCAL_PATH_MAP.get(card.image_url, NON_CARD_PATH)
                    battle_card = create_card(card.name, card.health, card.armor, card.base_damage, card.crit_rate, card.speed, card.chakra, card.element, card.tier)
                    battle_defender_team.append(battle_card)
                    defenderCardImgPaths.append(img_path)
                
                attackCardImgpaths = []
                for pc in attacker_cards:
                    key = pc.template.image_url
                    # n·∫øu kh√¥ng t√¨m th·∫•y key trong map th√¨ fallback sang NON_CARD_PATH n·∫øu b·∫°n c√≥
                    img_path = CARD_IMAGE_LOCAL_PATH_MAP.get(key, NON_CARD_PATH)
                    attackCardImgpaths.append(img_path)
                
                paths = attackCardImgpaths + defenderCardImgPaths
                buffer = renderImageFight(
                    paths[0], paths[1], paths[2],paths[3],BG_TAILED
                )
                filename = f"battle_{attacker_id}.png"
                battle_file = discord.File(buffer, filename=filename)

                for c in battle_attacker_team:
                    c.team      = battle_attacker_team
                    c.enemyTeam = battle_defender_team

                # --- G√°n team/enemyTeam cho defender ---
                for c in battle_defender_team:
                    c.team      = battle_defender_team
                    c.enemyTeam = battle_attacker_team
                
                # 1) G·ª≠i embed log ban ƒë·∫ßu k√®m ·∫£nh
                initial_desc = []
                initial_desc += render_team_status(battle_attacker_team, "**Team T·∫•n C√¥ng**")
                initial_desc += render_team_status(battle_defender_team, "**Team Ph√≤ng Th·ªß**")
                initial_desc.append("\nƒêang kh·ªüi ƒë·∫ßu tr·∫≠n ƒë·∫•u‚Ä¶")

                log_embed = discord.Embed(
                    title=f"ü¶ä {attacker.username} ƒëaÃÉ tiÃÄm th√¢ÃÅy {list_cards[0].name} trong hang",
                    description="\n".join(initial_desc),
                    color=discord.Color.blurple()
                )
                log_embed.set_image(url=f"attachment://{filename}")
                log_msg = await interaction.followup.send(
                    embed=log_embed,
                    file=battle_file,
                    wait=True
                )

                #..........................battle.................................
                battle = Battle(battle_attacker_team, battle_defender_team, maxturn=200)
                while (
                    battle.is_team_alive(battle.attacker_team) and
                    battle.is_team_alive(battle.defender_team) and
                    battle.turn <= battle.maxturn
                ):
                    for atk_team, def_team in (
                        (battle.first_team, battle.second_team),
                        (battle.second_team, battle.first_team)
                    ):
                        for c in atk_team:
                            if not c.is_alive():
                                continue
                            logs = battle.battle_turn_one_card(c)
                            static_lines = []
                            static_lines += render_team_status(battle_attacker_team, "**Team T·∫•n C√¥ng**")
                            static_lines += render_team_status(battle_defender_team, "**Team Ph√≤ng Th·ªß**")
                            desc = "\n".join(static_lines)
                            desc += f"\n--- L∆∞∆°Ã£t {battle.turn}: {c.name} ---\n"
                            desc += "\n".join(logs)

                            edit_embed = discord.Embed(
                                title=f"ü¶ä {attacker.username} ƒëaÃÉ tiÃÄm th√¢ÃÅy {list_cards[0].name} trong hang",
                                description=desc,
                                color=discord.Color.blurple()
                            )
                            edit_embed.set_image(url=f"attachment://{filename}")
                            await log_msg.edit(embed=edit_embed)
                            await asyncio.sleep(2)
                            battle.turn += 1
                            if not battle.is_team_alive(def_team):
                                break
                        if not battle.is_team_alive(def_team):
                            break

                bonus_reward = 0  # s·ªë ti·ªÅn th∆∞·ªüng d·ª±a tr√™n vi·ªác ƒë√°nh b·∫°i ƒë·ªëi th·ªß
                damageDead = 0 # saÃÅt th∆∞∆°ng g√¢y ra l√™n boss
            with getDbSession() as session2:
                playerRepo2 = PlayerRepository(session2)
                fresh_attacker = playerRepo2.getById(attacker_id) 
                # x√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng
                if battle.turn >= battle.maxturn:
                    result = "üè≥Ô∏è Ho√†"
                    outcome_text = f"‚öîÔ∏è sau 200 l∆∞∆°Ã£t baÃ£n kh√¥ng haÃ£ ƒë∆∞∆°Ã£c {list_cards[0].name} n√™n hoÃÄa, haÃÉy quay laÃ£i sau 1 ti√™ÃÅng"
                    damageDead = battle_defender_team[0].max_health - battle_defender_team[0].health
                    bonus_reward = damageDead * 50
                    fresh_attacker.coin_balance += bonus_reward
                    damageDeadTxt = f"baÃ£n ƒëaÃÉ g√¢y ra {damageDead} saÃÅt th∆∞∆°ng l√™n {list_cards[0].name}"
                    thuong = f"üí∞**Th∆∞·ªüng:** {bonus_reward:,} Ryo"
                elif battle.is_team_alive(battle.attacker_team):
                    result = "Chi√™ÃÅn ThƒÉÃÅng"
                    damageDead = battle_defender_team[0].max_health
                    bonus_reward = damageDead * 50
                    fresh_attacker.coin_balance += bonus_reward

                    if list_cards[0].tier in type1OfTailed:
                        rates = GACHA_DROP_RATE["card_advanced"]
                        tiers = list(rates.keys())
                        weights = list(rates.values())
                        outcomeTier = random.choices(tiers, weights=weights, k=1)[0]
                        card = cardtemplaterepo.getRandomByTier(outcomeTier)
                        playerCardRepo.incrementQuantity(attacker_id, card.card_key, increment=1)
                        thuong = f"üí∞**Th∆∞·ªüng:** {list_cards[0].name} ch√™ÃÅt vaÃÄ r∆°i ra {bonus_reward:,} Ryo vaÃÄ theÃâ {card.name}(b√¢Ã£c {card.tier})"
                    elif list_cards[0].tier not in type1OfTailed:
                        rates = WEAPON_GACHA_DROP_RATE["weapon_pack"]
                        tiers = list(rates.keys())
                        weights = list(rates.values())
                        outcomeTier = random.choices(tiers, weights=weights, k=1)[0]
                        weapon = weaponTemplateRepo.getRandomByGrade(outcomeTier)
                        playerWeaponRepo.incrementQuantity(attacker_id, weapon.weapon_key, increment=1)
                        thuong = f"üí∞**Th∆∞·ªüng:** {list_cards[0].name} ch√™ÃÅt vaÃÄ r∆°i ra {bonus_reward:,} Ryo vaÃÄ vuÃÉ khiÃÅ {weapon.name}(b√¢Ã£c {weapon.grade})"

                    damageDeadTxt = f"baÃ£n ƒëaÃÉ g√¢y ra {damageDead} saÃÅt th∆∞∆°ng l√™n {list_cards[0].name}"
                    outcome_text = f"b·∫°n ƒë√£ chi·∫øn th·∫Øng {list_cards[0].name} v√† ƒë√£ nh·∫≠n th∆∞·ªüng, h√£y quay l·∫°i sau 1 ti√™ÃÅng."
                    
                else:
                    result = "Th√¢ÃÅt BaÃ£i"
                    outcome_text = f"b·∫°n ƒë√£ biÃ£ {list_cards[0].name} ƒë√¢ÃÅm ch√™ÃÅt vaÃÄ nh√¢Ã£n th∆∞∆°Ãâng, h√£y quay l·∫°i sau 1 ti√™ÃÅng."
                    damageDead = battle_defender_team[0].max_health - battle_defender_team[0].health
                    bonus_reward = damageDead * 50
                    fresh_attacker.coin_balance += bonus_reward
                    damageDeadTxt = f"baÃ£n ƒëaÃÉ g√¢y ra {damageDead} saÃÅt th∆∞∆°ng l√™n {list_cards[0].name}"
                    thuong = f"üí∞**Th∆∞·ªüng:** {bonus_reward:,} Ryo"

                session2.commit()

                # 3) G·ª≠i embed k·∫øt qu·∫£ cu·ªëi c√πng
                result_embed = discord.Embed(
                    title=f"üèÅ K·∫øt quaÃâ tr√¢Ã£n chi√™ÃÅn cuÃâa {fresh_attacker.username} VS {list_cards[0].name}",
                    description=(
                        f"üéñÔ∏è **K·∫øt qu·∫£:** {result}\n"
                        f"{thuong}\n\n"
                        f"{damageDeadTxt}\n\n"
                        f"{outcome_text}"
                    ),
                    color=discord.Color.green() if result == "Chi√™ÃÅn ThƒÉÃÅng" else discord.Color.red()
                )
                result_embed.set_footer(text=f"ƒêi·ªÉm Rank: {fresh_attacker.rank_points}")
                await interaction.followup.send(embed=result_embed)

        except Exception as e:
            tb = traceback.format_exc()
            await interaction.followup.send(
                f"‚ùå C√≥ l·ªói x·∫£y ra:\n```{tb}```",
                ephemeral=True
            )
    @tailedboss.error
    async def buycard_error(self, interaction: discord.Interaction, error):
        if isinstance(error, CommandOnCooldown):
            await interaction.response.send_message(
                f"‚è±Ô∏è B·∫°n ph·∫£i ch·ªù **{error.retry_after:.1f}** gi√¢y n·ªØa m·ªõi ƒëaÃÅnh ƒë∆∞∆°Ã£c viÃÉ thuÃÅ.",
                ephemeral=True
            )
        else:
            # V·ªõi l·ªói kh√°c, ta v·∫´n raise l√™n ƒë·ªÉ discord.py x·ª≠ ho·∫∑c log
            raise error

async def setup(bot):
    await bot.add_cog(TailedBoss(bot))
